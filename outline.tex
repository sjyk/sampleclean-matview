\documentclass{sig-alternate}

\usepackage{enumitem}
\usepackage{framed}
\usepackage{listings}
\usepackage{amstext}
\usepackage{amstext}
\usepackage{pdfpages}
\usepackage{alltt}
\usepackage{epstopdf}
\usepackage{xspace,colortbl}
\usepackage[USenglish]{babel}
\usepackage{multirow}
\usepackage{url}
\usepackage{subfigure}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{fmtcount}
\usepackage{amsfonts}
\usepackage{xspace}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage[mathscr]{eucal}
%\usepackage{psfrag}
\usepackage{colortbl}
\usepackage{bm}
\usepackage[nospace]{cite}




\lstset{basicstyle=\small,breaklines=true}

\linespread{0.94}%

\begin{document}


\newtheorem{theorem}{Theorem}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\newcommand{\dataset}{data set\xspace}
\newcommand{\datasets}{data sets\xspace}
\newcommand{\spview}{\textsf{SPView}\xspace}
\newcommand{\fjview}{\textsf{FJView}\xspace}
\newcommand{\aggview}{\textsf{AggView}\xspace}
\newcommand{\hashfunc}[1]{\textsf{hashfunc}(#1)\xspace}

\newcommand{\avgfunc}{\ensuremath{\texttt{avg} }\xspace}
\newcommand{\countfunc}{\ensuremath{\texttt{count}}\xspace}
\newcommand{\sumfunc}{\ensuremath{\texttt{sum} }\xspace}


\newcommand{\tbl}[1]{\textsf{#1}\xspace}
\newcommand{\field}[1]{\textsf{#1}\xspace}
\newcommand{\cost}{\textrm{cost}\xspace}
\newcommand{\ans}{\textsf{ans}\xspace}
\newcommand{\dans}{\Delta\textsf{ans}\xspace}
\newcommand{\cqp}{correcting query processing\xspace}
\newcommand{\Cqp}{Correcting query processing\xspace}

\newcommand{\reminder}[1]{{{\textcolor{magenta}{\{\{\bf #1\}\}}}\xspace}}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

%\newcommand{\reminder}[1] {}
\pagestyle{plain}

\title{A Data Cleaning Approach for Approximately Up-To-Date Results on Stale Materialized Views}

\maketitle

\begin{abstract}
Materialized views, stored pre-computed query results, are used to optimize queries on large datasets.
Materialized views can become out-date when base tables change and any queries issued to these views give \emph{stale} results.
Incrementally maintaining these results, as opposed to full recalculation, has been well studied but is often infeasible to for every incoming update.
To defer these costs, materialized views are often updated periodically in batches leading to long periods of staleness.
In this work, we model this problem as a data cleaning problem.
We use a sample of data to estimate how updates affect query results and then use the estimate to clean a stale result on the materialized view; compensating for the effect of the updates.
We couple this approach with outlier indexing to give query results that are robust to skewed distributions. 
We bound estimates for common aggregate queries (SUM, COUNT, AVG) in analytic confidence intervals.
We evaluate this approach on real and synthetic datasets and in both a single node (MySQL) and distributed environment (Apache Spark).
Our results suggest that using sampling dramatically reduces maintenance costs while not sacrificing much accuracy.
In a large scale experiment using 20-node Apache Spark cluster, we derived views from a 1TB activity log dataset and found that maintaining a 1\% sample was 87x faster yet only with mean query error of 4\%.
\end{abstract}

\input{introduction.tex}
\input{problem_statement.tex}
\input{architecture.tex}
\input{correction.tex}
\input{sampling.tex}
\input{outlier.tex}
\input{analysis.tex}
\input{experiments.tex}
\input{conclusion.tex}

\bibliographystyle{abbrv}
\fontsize{6.8pt}{6.7pt} \selectfont
\bibliographystyle{abbrv}
\bibliography{ref} 

\end{document}