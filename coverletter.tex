\textbf{We bolded our revisions to Section 4.4}

\emph{4.4 Hashing Operator}

The primary keys allow us to determine the set of rows that contribute to a row $r$ in a derived relation.
If we have a deterministic way of mapping a primary key to a Boolean, we can ensure that all contributing rows are also sampled. 
To achieve this we use a hashing procedure.
Let us denote the hashing operator $\eta_{a, m}(R)$. 
\textbf{For all tuples in R, this operator applies a hash function whose range is $[0,1]$ to primary key $a$ (which may be a set) and selects those records with hash less than or equal to $m$ \footnote{For example, if hash function is a 32-bit unsigned integer which we can normalize by \texttt{MAXINT} to be in $[0,1]$.}}.

\textbf{
In this work, we study uniform hashing where the condition $h(a) \le m$ implies that a fraction of approximately $m$ of the rows are sampled.
Such hash functions are utilized in other aspects of database research and practice (e.g. hash partitioning, hashed joins, and hash tables).
Hash functions in these applications are designed to be as uniform as possible to avoid collisions.
There are numerous empirical studies that establish that for many commonly applied hash functions (e.g., Linear, SDBM, MD5, SHA) the difference with a true uniform random variable is very small \cite{henke2009empirical, l2007testu01}.
Cryptographic hashes work particularly well and are supported by most commercial and open source systems, for example MySQL provides MD5 and SHA1/2.}

%This definition is without loss of generality for uniform hash function, as if we have a hash function whose range is the set of integers (as implemented in MySQL or Apache Hive) we can take the absolute value and divide by the maximum integer mapping this range back $[0,1]$. 

To avoid materializing extra rows, we push down the hashing operator through the expression tree.
The further that we can push $\eta$ down, the more operators (i.e., above the sampling) can benefit.
This push down is analogous to predicate push-down operations used in query optimizers. 
In particular, we are interested in finding an optimized relational expression that materializes an identical sample before and after the push down.
We formalize the push down rules below:
\begin{definition}[Hash push down]
For a derived relation $R$, the following rules can be applied to push $\eta_{a, m}(R)$ down the expression tree. 
\begin{itemize}[noitemsep]
\item $\sigma_{\phi}(R)$: Push $\eta$ through the expression.  
\item $\Pi_{(a_1,...,a_k)}(R)$: Push $\eta $ through if $a$ is in the projection.
\item $\bowtie_{\phi (r1,r2)}(R_1,R_2)$: No push down in general. There are special cases below where push down is possible.
\item $\gamma_{f,A}(R)$: Push $\eta $ through if $a$ is in the group by clause $A$.
\item $R_1 \cup R_2$: Push $\eta $ through to both $R_1$ and $R_2$
\item $R_1 \cap R_2$: Push $\eta $ through to both $R_1$ and $R_2$
\item $R_1 - R_2$: Push $\eta $ through to both $R_1$ and $R_2$
\end{itemize}
\end{definition}

\noindent \textbf{Special Case of Joins: }
\textbf{In general, a join $R \bowtie S$ blocks the pushdown of the hash function $\eta_{a, m}(R)$ since $a$ possibly consists of attributes in both $R$ and $S$.
However, when there is a constraint that enforces these attributes are equal then pushdown is possible.}

\emph{Foreign Key Join. } If we have a join with two foreign-key relations $R_1$ (fact table with foreign key $a$) and $R_2$ (dimension table with primary key $b \subseteq a$) and we are sampling the key $a$, then we can push the sampling down to $R_1$. This is because we are guaranteed that for every $r_1\in R_1$ there is only one $r_2 \in R_2$. 

\emph{Equality Join. } If the join is an equality join and $a$ is one of the attributes in the equality join condition $R_1.a = R_2.b$, then $\eta$ can be pushed down to both $R_1$ and $R_2$. On $R_1$ the pushed down operator is $\eta_{a, m}(R_1)$ and on $R_2$ the operator is $\eta_{b, m}(R_2)$. 

\begin{example}\bf
We illustrate our hashing procedure in terms of SQL expressions on our running example.
We can pushdown the hash function for the following expressions:
\begin{lstlisting}
SELECT * FROM Video WHERE Predicate()
SELECT * FROM Video,Log WHERE Video.videoId = Log.videoId
SELECT videoId, count(1) FROM Log GROUP BY videoId
\end{lstlisting}
\vspace{0.3em}
The following expressions are examples where we cannot pushdown the hash function:
\begin{lstlisting}
SELECT * FROM Video, Log

SELECT c, count(1)
FROM ( 
       SELECT videoId, count(1) as c FROM Log 
       GROUP BY videoId
     )
GROUP BY c
\end{lstlisting}

\end{example}

\begin{theorem}
Given a derived relation $R$, primary key $a$, and the sample $\eta_{a, m}(R)$.
Let $S$ be the sample created by applying $\eta_{a, m}$ without push down and 
$S'$ be the sample created by applying the push down rules to $\eta_{a, m}(R)$.
$S$ and $S'$ are identical samples with sampling ratio $m$.
\end{theorem}
\begin{proof}[Sketch]
We can prove this by induction.
The base case is where the expression tree is only one node, trivially making this true.
Then, we can induct considering one level of operators in the tree.
$\sigma, \cup, \cap, -$ clearly commute with hashing the key $a$ allowing for push down.
$\Pi$ commutes only if $a$ is in the projection.
For $\bowtie$, a sampling operator on $Q$ can be pushed down if $a$ is in either $k_r$ or $k_s$, or if there is a constraint that links $k_r$ to $k_s$.
For group by aggregates, if $a$ is in the group clause (i.e., it is in the aggregate) then a hash of the operand filters all rows that have $a$ which is sufficient to materialize the derived row.
\end{proof} 

































































 


