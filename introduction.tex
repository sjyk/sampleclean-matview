\vspace{-0.5em}
\section{Introduction}
Materialized views (MVs) are a well-known approach to improving query processing performance \cite{LarsonY85, gupta1995maintenance, chirkova2011materialized, halevy2001answering}.
During the last 30 years, the research community has thoroughly studied MVs, and all major database vendors have added support for them.
In a world of ever-increasing data sizes, MVs are becoming even more important, both for traditional query processing
 \cite{lefevre2014opportunistic, bailis2014scalable, perez2014history} and for more advanced analytics based on linear algebra and machine learning \cite{nikolic2014linview, zhang2014mat}.

MVs are effectively stored, pre-computed query results, so when the underlying data is changed MVs can become \emph{stale}. 
Incremental view maintenance has been developed to address this problem\cite{gupta1995maintenance, chirkova2011materialized}. 
Instead of re-creating an entire view for every update, incremental view maintenance executes only the incremental changes required to ensure that an MV accurately reflects the current state of the base data.  
There has been substantial work in optimizing incremental maintenance algorithms \cite{DBLP:conf/sigmod/GriffinL95, griffin1997improved, samtani1999self, DBLP:conf/sac/TrutaC07, DBLP:journals/vldb/KochAKNNLS14}.
 
However, for frequently changing tables even incremental maintenance can be expensive; every update to the underlying data requires updating all the dependent views.  
This problem is exacerbated in Big Data environments, where new records arrive at an increasingly fast rate and where data are often 
distributed across multiple machines.  
As a result, in production environments it is common to defer view maintenance to a later time \cite{chirkova2011materialized, zhou2007lazy, DBLP:conf/sigmod/ColbyGLMT96} so that updates can be batched together to amortize overheads and maintenance work can be scheduled for times of low system utilization.  

While deferring maintenance has compelling benefits, it unfortunately brings its own costs, namely that views become increasingly stale in-between maintenance periods. 
As a result, queries on those views can return increasingly incorrect answers.  
In a sense, stale MVs are dirty data, and queries over them therefore suffer from inaccuracies.   
The observation that stale MVs are a type of dirty data leads us to the key insight behind our work; namely, that data cleaning techniques can be used to mitigate the negative impacts of deferred MV maintenance.  

\begin{figure}[t] \vspace{-2em}
\centering
 \includegraphics[scale=0.30]{figs/sys-arch.pdf} \vspace{-.25em}
 \caption{\reminder{Fix with new story} SVC has three main components: (1) sampling, (2) correction, and (3) outlier indexing. From a sample of up-to-date data, we estimate
 a correction for queries on stale MVs. To make this process robust to outliers, we apply a technique called outlier indexing. \label{sys-arch}}\vspace{-1.75em}
\end{figure}

Data cleaning has been studied extensively in the literature (e.g., see Rahm and Do for a survey\cite{rahm2000data}) but increasing data volumes and arrival rates have led to development of new, efficient sampling-based approaches for coping with dirty data.   
In our prior work, the SampleClean framework has been shown to greatly improve query accuracy while cleaning only a small sample of dirty records rather than an entire dirty data set \cite{wang1999sample}.  
We proposed an algorithm called \textbf{NormalizedSC} that corrects dirt query results by using a sample of clean data to learn how the dirtiness affects the and then calculates a correction.  
This perspective raises a new possibility for MVs: we can return more accurate query results without incurring the cost of full view maintenance.
Of course, the metaphor of stale MVs as dirty data only goes so far. 
View staleness is a different type of error than typical dirty data, which raises interesting new challenges in sampling, cleaning, and efficient query processing.

To address these new challenges, we propose Sample-View-Clean (SVC), a framework that uses a \emph{sample} of up-to-date data to \emph{correct} stale query results.  
While approximate, the corrected query result can be bounded within confidence intervals.
SVC is complementary to existing deferred maintenance approaches; when the MVs become stale between maintenance cycles, we can apply SVC for cleaning results for a far smaller cost than having to maintain the entire view.
SVC gives results that are fresh, with a bounded approximation error that can be controlled by adjusting the sampling ratio.
This is opposed to a possibly unbounded staleness.

\reminder{this is new}
A key theoretical insight is that instead of randomly sampling the updates to the base relations as is common in the streaming literature \cite{babcock2002sampling, DBLP:journals/pvldb/MankuM12}, we apply a deterministic \textbf{hash mod} operation to sample the rows in a view.
Then, working backwards through relational expression that defines the view using tuple lineage \cite{DBLP:journals/vldb/CuiW03}, we do just enough work to maintain those rows.
The result is an up-to-date uniform sample which can be used to give unbiased corrections of aggregate queries (e.g. \sumfunc, \countfunc, \avgfunc), and in fact, we can support the same set of aggregate queries supported in the AQP literature \cite{AgarwalMPMMS13, agarwalknowing}.
Since sampling is known to be sensitive to outliers (i.e., rows that have abnormal attribute values), we
utilize a technique called outlier indexing \cite{chaudhuri2001overcoming} to ensure that MV rows that are derived from ``outlier" records are accounted for in the sample which we found significantly increases accuracy in skewed data sets.

The theoretical scope of the SVC is quite general, and our approach can be applied, in principle, to any multiset-valued materialized view.
However, of course, there are a subclass of views for which sampling can save significant computation and a subclass of queries on these views for which our corrections are accurate.
In this work, we explore these classes from both a theoretical perspective (i.e. when is our query correction optimal w.r.t estimate variance) and an empirical perspective for queries that do not satisfy the optimality conditions when is SVC still useful.

To summarize, our contributions are as follows:
\begin{itemize}\vspace{-.45em}
\item We model the incremental maintenance problem as a data cleaning problem and staleness as a type of data error.\vspace{-.45em}
\item Given an incremental maintenance plan and a stale view, we show how sampling with a \textbf{hash mod} operation can reduce computation. We further show how we can use knowledge about integrity constrains (such as foreign keys) to optimize the sampling process. \vspace{-.45em}
\item We derive a correction for aggregate queries using the sample and show that, in fact, our correction is optimal for \sumfunc, \countfunc, and \avgfunc. \vspace{-.45em}
\item We use an outlier index to increase the accuracy of the approach for power-law, long-tailed, and skewed distributions.\vspace{-.45em}
\item We evaluate our approach on a single-node MySQL database with a 10GB skewed TPCD benchmark dataset and on a 20-node Apache Spark cluster with a 1TB log dataset from a video streaming company. Our results show that sampling is significantly faster than full view maintenance, and also can give highly accurate results for a variety of queries and views.\vspace{-.45em}
\end{itemize}

The paper is organized as follows: 
In Section~\ref{sec-background}, we introduce MVs and discuss the current maintenance challenges.
Next, in Section~\ref{sec-arch}, we give a brief overview of our overall system architecture.
In Section~\ref{sampling} and~\ref{correction}, we describe the sampling and query processing of our technique.
In Section~\ref{outlier}, we describe the outlier indexing framework.
In Section~\ref{sec:ext}, we discuss how SVC extends to Select queries and deletions.
Then, in Section~\ref{exp}, we evaluate our approach.
Finally, we discuss Related Work in Section~\ref{related} and present our Conclusions and Future Work in Section~\ref{conclusion}.
