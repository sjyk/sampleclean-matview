\section{Introduction}
Materialized views, stored pre-computed query results, are used to optimize query processing on large datasets \cite{gupta1995maintenance, chirkova2011materialized, halevy2001answering}.
Materialization and related concepts such as selecting which queries to materialize
have been well studied in recent research \cite{zaharia2012resilient,lefevre2014opportunistic, bailis2014scalable, perez2014history}.
This research has further expanded beyond the SQL setting \cite{nikolic2014linview} and 
has shown promising results when applied to numerical linear algebra and machine learning.
However, when derived from frequently changing tables,
materialized views face the obvious challenge of \emph{staleness} where the pre-computed results need to be updated to reflect the changes in the base tables.
To avoid expensive recalculation, incrementally updating materialized views,
also called incremental maintenance, has been well studied \cite{gupta1995maintenance, chirkova2011materialized}.

Unfortunately, in many desired applications, incremental maintaining the view for every incoming update can be very costly. 
When the base tables change rapidly, the database system has to propagate each update to all of the materialized views.
Consequently, there are many techniques that defer updating the views to a later time or trigger the updates only when neccessary \cite{chirkova2011materialized, zhou2007lazy}.
Deferral allows for many advantages such as batching updates together to amortize overheads and scheduling updates at times when there are more system resources available eg. at night.
Deferral strategies provide increased flexibility to meet the resource constraints of the system, but may not guarantee that the views will always be up-to-date.
When a materialized view is out-of-date during a maintenance gap, queries issued to the view can have \emph{stale} results. 

In this work, we address the incremental maintenance problem from a different perspective.
We explore whether refreshing stale rows in a materialized view can be modeled as data cleaning problem and whether stale query results can be ``cleaned".
While much of the data cleaning literature focuses on improving query accuracy on dirty datasets,
there has been an increasing trend of considering the costs of data cleaning \cite{wang1999sample}.
In particular, recent results show that to answer aggregate queries, such as SUM, COUNT, and AVG, on dirty datasets, it suffices to clean a small, representative sample of records.
This model raises an intruiging possibility for materialized views, namely, that a sample of up-to-date data can be used to answer aggregate queries without having the maintain the entire materialized view.
In our proposed approach, given a stale query result, we sample updates to the materialized view, and we use the sample to estimate a correction to compensate for the effects of the new updates thus ``cleaning" the dirty result.
While approximate, the corrected query result can be bounded withing confidence intervals.
Existing techniques allow the user to control the freshness of queries by chosing maintenance parameters (e.g. nightly maintenance vs. hourly maintenance) based on prior experience, however, without bounds on the results, a burst of updates can lead to unexpected changes in query accuracy.
On the other hand, our approach gives results that are, in expectation, always fresh and the user controls the tightness of the bound with the sampling ratio.
%The SampleClean project [?] studied a related problem of bounding aggregate queries on dirty datasets but did not consider materialized views or the effect of missing records.

Our approach has three components: (1) sampling, (2) correction, and (3) outlier indexing. In (1), we sample the updates to the view in a way that ensures that the sample is representative of the up-to-date data. Updates can affect different classes of views differently, and we define a logical unit called an ``update pattern" which represents how an update affects the derived view. Our system maintains a sample of the ``update patterns" and uses this sample to derive a correction. (2) we use the sampled update pattern to derive a correct aggregate queries on stale materialized views.
From the sample, we estimate how much the updates affect the query in question and we use this estimate to adjust the query result when applied to a stale view.
Finally, in (3) sampling has the potential to mask outliers, and in fact, it is known
heavy-tailed distributions are poorly approximated from samples \cite{chaudhuri2001overcoming}.
In this framework, we utilize a technique called outlier indexing \cite{chaudhuri2001overcoming}, which guarantees that rows in the materialized view derived from an ``outlier" record (one that has abnormal attribute values) is contained in the sample.
Coupling outlier detection with sampling has an interesting implication; not only can we answer exact selection queries on the outliers, but
the information from the outliers can potentially improve query accuracy or likewise reduce the number of needed samples.

Our approach can be implemented with a relatively small overhead: at maintenance time the generation of random numbers to build the sample, and at query execution time single pass over a small sample of data to estimate a correction for the query.
Consequently, sampling can significantly save on maintenance costs and give a flexible tradeoff between accuracy and performance.
To summarize, our contributions are as follows:
\begin{itemize}
  \item We model the incremental maintenance problem as a data cleaning problem and propose a technique to approximately clean stale results; providing a flexible tradeoff between accuracy and performance.
  \item We use an outlier index to increase the accuracy of the approach for power-law, long-tailed, and skewed distributions.
  \item We analyze the costs of our approach and show analytically and empirically that it can result in dramatic reductions in view maintenance time.
  \item We evalaute our approach on real and synthetic datasets and in both the single node and distributed environments.
\end{itemize}

The paper is organized in the following way. 
In Section \ref{sec-background}, we introduce materialized views and discuss the current maintenance challenges.
Next, in Section \ref{sec-arch}, we give a brief overview of our overall system architecture.
In Section \ref{sampling} and \ref{correction}, we describe the mathematics and query processing of our technique.
In Section \ref{outlier}, we describe the outlier indexing framework.
Finally in Section \ref{exp}, we evalaute our approach.

\iffalse
 These two pieces can be costly in different
applications. (1) In distributed environments where the view is partitioned
over a cluster, incremental view maintenance often neccesitates communicating
the delta view. (2) Systems such as Apache Spark, Cloudera Impala,
and Apache Tez {[}?{]} offer materialized view support, however, are
not optimized for selective updates nor have native support for indices.
This can lead to high maintenance costs in applications where the
views are derived from joins that are not aligned with the partitioning
of the base tables. (3) Base data is often raw requiring pre-processing
such as string processing, deserialization, and formatting; all of
which can can be expensive to run on a large number of updates. 



Querying a stale view is similar to problems studied in data cleaning{[}?{]}.
When databases are dirty, query results can be arbitrarily wrong.
Data cleaning is used to remove data errors but this can be very costly either 
requiring machine learning to classify errors or even human intervention.
SampleClean is a query processing framework that answers aggregate
queries on dirty datasets by applying potentially expensive cleaning
techniques to just a sample. The results, while approximate, are bounded
with respect to the clean data and the system offers a flexible tradeoff
between cleaning cost and result accuracy. Similarly, a stale row
and an expensive incremental maintenance scheme, mirrors the problem
setting studied in SampleClean. 

In this paper, we propose a data cleaning approach for approximate,
bounded aggregation queries on stale views. Instead of maintaining
the entire view, we maintain only a small sample of the view. Then
given an aggregation query on this view, from this small sample, we
can estimate how the updates affect the query result. We apply this
estimate to correct the dirty aggregation query result on the stale
data. We call this approach \emph{approximate query correction}. 
These corrections are provably bounded, in contrast to the unbounded stalness,
and the sampling gives a flexible tradeoff to meet performance constraints such as throughput.
Sampling helps reduces both bottlenecks in view maintenance, delta
view calculation and view updating, as it reduces the number of updates
that need to processed and then written.

Another relevant concept from data cleaning is outlier detection {[}?{]}.

In this work, we propose an outlier indexing framework that guarantees that
rows in the materialized view derived from an ``outlier" record, one with
an abnormal attribute value, are included in the sample.

In summary, our contributions are as follows:
\begin{itemize}
\item We present a query processing framework that corrects aggregation queries on stale
views using a sample of up-to-date data.
\item We couple this approach with an oultier indexing framework that allows
for selection queries on outliers and we show both analytically and empirically that 
this can improve query accuracy.
\item We evaluate our approach on two systems, Apache SparkSQL and MySQL,
and discuss how the different systems affect performance performance
parameters.
\end{itemize}
\fi
