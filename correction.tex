\section{Sampling a Maintenance Plan}
\label{sampling}
In this section, we discuss how to efficiently optimize the sampled maintenance plan $\eta(\mathcal{M})$ and under what conditions the time-complexity of executing $\eta(\mathcal{M})$ is less than that of executing $\mathcal{M}$.
Let the result of this execution is an up-to-date sampled materialized view $\hat{S'}$ which is a uniformly sampled subset of $S'$.

The intuition is straight-forward, if we sample the maintenance plan and we have some way of keep track of which tuples are in our sample, we only have to do as much work as neccessary to maintain those tuples. 
However, this is nuanced as it requires us to formalize the notion of tuple ``lineage"; ie. the conditions under which we can trace a tuple in a materialized view to its base relation.

\subsection{Tuple Lineage}
Lineage has been an important tool in the analysis of materialized views \cite{DBLP:journals/vldb/CuiW03} and in approximate query processing \cite{DBLP:conf/sigmod/ZengGMZ14}.
In our case, when we sample a maintenance plan, we need a way of identifying all the intermediate results that affect a sampled tuple.

\begin{definition}
(LINEAGE CONDITION). All views $S$ and maintenance plans $\mathcal{M}$ must satisfy the lineage condition which is defined inductively on a query tree:
\begin{itemize}\vspace{-.45em}
\item Base Case: All relations (leaves) must have an attribute $p$ which is designated as a primary key.\vspace{-.45em}
\item $\sigma_{\phi}(R)$: Always preserves lineage of R \vspace{-.45em}
\item $\Pi_{p,(a_2,...,a_k)}(R)$: Preserves lineage of R if it includes $p$ \vspace{-.45em}
\item $\bowtie_{\phi (r1,r2)}(R_1,R_2)$: Resets lineage. The primary key of the result is the union of the linages of the relations $p= p_1 \cup p_2$.
\item $\gamma_{e}(R)$: Resets lineage. The primary key of the result is the group by expression $e(R)$.\vspace{-.45em}
\item $R_1 \dot{\cup} R_2$: Always preserves lineage
\item $R_1 \dot{\cap} R_2$: Always preserves lineage 
\item $R_1 \dot{-} R_2$: Always preserves lineage 
\end{itemize}
\end{definition}

The above definition is also constructive; that is, if a view or a maintainance plan does not satisfy the Lineage Condition we can modify the plan so that it does.
We modify every projection operation to ensure that primary key of the relation is never projected out of the next level of the query tree.

\subsection{Hashing Operator}
Now, we analyze the sampling operator $\eta_{a, m}(R)$. 
The sampling applies a hash function to the attribute a $h:\mathbb{A} \mapsto [0,1]$.
If the hash function is sufficiently uniform, then $h(a) \le m$ samples on average a fraction $m$ of the tuples.
This definition is without loss of generality for uniform hash function, as if we have a hash function whose range is the set of integers (as implemented in MySQL or Apache Hive) we can take the absolute value and divide by the maximum integer mapping this range back $[0,1]$.
We apply the sampling operator to the top of the maintenance plan query tree.
Since the maintenance plan satisfies the Lineage Condition, we can apply it the primary key of the maintenance plan's query tree.

For reasons that will be clear in the subsequent sub-sections, hashing as opposed to random sampling allows us to push down the operator through some types of joins and aggregates. 
It enforces that tuples in the result relation are either correct (fully joined or aggregated) or missing altogether.

\subsection{Pushdown Of The Hashing Operator}
To achieve the performance benefits of sampling, we can now push down the hashing operator through the query tree.
The further than we can push $\eta$ down the query tree, the more operators can benefit from the sampling.
We make two assumptions on this hash operator: (1) \emph{independence} there is no expression in $S_{def}$ that is dependent on the hash operator, and (2) \emph{uniformity} over the domain of possible attribute values the \emph{a priori} probability of including any tuple is the same.

\begin{proposition}
(HASH PUSHDOWN). Assuming the query tree satisfies the Lineage Condition, then the following rules can be applied to push $\eta(a)$ down the query tree. 
\begin{itemize}\vspace{-.45em}
\item $\sigma_{\phi}(R)$: Push $\eta$ through \vspace{-.45em}
\item $\Pi_{p,[a_2,...,a_k]}(R)$: Push $\eta $ through \vspace{-.45em}
\item $\bowtie_{\phi (r1,r2)}(R_1,R_2)$: Blocks $\eta $ in general. See (Section ??) for conditions when push down is possible.
\item $\gamma_{e}(R)$: Blocks $\eta$ in general. If the group by expression can be decomposed into $e(R) = a, e'(R)$ then pushdown is posible.\vspace{-.45em}
\item $R_1 \dot{\cup} R_2$: Push $\eta $ through to both $R_1$ and $R_2$
\item $R_1 \dot{\cap} R_2$: Push $\eta $ through to both $R_1$ and $R_2$
\item $R_1 \dot{-} R_2$: Push $\eta $ through to both $R_1$ and $R_2$
\end{itemize}
\end{proposition}

The key property that we exploit is that hashing gives us a deterministic sample.
By hashing only on certain keys, we can further ensure \emph{sample completeness} of $\bowtie$.
That is, for all $r_1\in R_1$ if $(r_1,r_2)$ satisfies the join condition and $(r_1,r_2')$ satisfies the join condition; they are both inside the sample or both excluded from the sample. 
Hashing allows us to enforce this condition without having to check a table.
The same logic extends to $\gamma$, in the sample, either all rows satisfying the group condition are aggregated or none are.

To formalize, the proposed pushdown rules preserve the following property:
\begin{proposition} (SAMPLE COMPLETENESS) At every node in the query tree of sampled maintenance plan $\eta_{(a,m)}(\mathcal{M})$, we say the relation $R_s$ at the node is \emph{sample complete} if at every corresponding node $R$ in the unsampled maintenance plan $\eta_{(a,1)}(\mathcal{M})$:
\[ \forall r_s \in R_s : r_s \in R \]
\end{proposition}
In other words, every tuple (of every subexpression) in the sampled maintenance plan is found in the unsampled plan. 

\subsection{More About Joins}
The rules preserve sample completeness for the general operators. 
However, in special cases, we can achieve even further pushdown of the hashing operator. 

\textbf{Many-to-one Join: } If we have an join with two relations $R_1$ and $R_2$ and we know that for every $r_1 \in R_1$ there is at most one $r_2$ in $R_2$ that satisfies the join condition, then we push $\eta$ down to $R_1$.

\textbf{One-to-one Join: } If we have the previous condition and also the converse is true for every $r_2 \in R_2$ there is at most one $r_1$ in $R_1$, then we push $\eta$ down to $R_1$ and $R_2$.

\textbf{(Semi/Anti)-Join: } We can always push $\eta$ down on Semi-joins. For anti-joins we can push $\eta$ down because we can rewrite the node as $R_1 \dot{-} (R_1 \ltimes R_2) $ and apply the pushdown rules for set difference and Semi-Joins.

\subsection{Maintenance Savings}
\reminder{TODO}

\subsection{Running Example: Log Analysis}
Recall the example view ``LogView" in the previous section:
\begin{lstlisting} 
CREATE VIEW LogView AS 
SELECT videoId, 
count(1) AS slowResponseTimes 
FROM Log, Video
WHERE Log.videoID = Video.videoID and
    responseTime > .1*Video.duration
GROUP BY videoId;
\end{lstlisting}

Assume that insertions have been added to the Log table, and we call the set of insertions LogUpdates.
To update this view, we need to join the delta-relation LogUpdates with the Video table and then aggregate the counts.
After that, there are two cases: the video already exists in the stale view (in which case we have to update the count), or
the video does not exist in which case we insert a new row.
The following intentionally pedantic SQL maintenance plan can produce the updated view:
\begin{lstlisting}
 SELECT videoId, 
       LogView.slowResponseTimes + 
          deltaView.slowResponseTimes
 FROM LogView,
  (SELECT videoId, 
        count(1) AS slowResponseTimes 
   FROM LogUpdates, Video
   WHERE Log.videoID = Video.videoID and
        responseTime > .1*Video.duration
   GROUP BY videoId ) as deltaView
 WHERE LogView.videoId = deltaView.videoID

UNION 

  SELECT videoId, 
        count(1) AS slowResponseTimes 
  FROM LogUpdates, Video
  WHERE Log.videoID = Video.videoID and
        responseTime > .1*Video.duration
        Log.videoID NOT IN 
            (SELECT videoID FROM LogView)
  GROUP BY videoId

\end{lstlisting}
\reminder{figure here for the query tree}
If we apply the rules listed above and sample this maintenance plan, we find that we can push down the hash operator to LogView (hash on videoId) and LogUpdates (hash on videoId). 
This reduces the complexity for join between LogUpdates and Video, the subquery aggregation, and the join for deltaView and LogView.
